<template>
  <div>
    <Toast ref="toast"></Toast>
    <draggable
      v-model="draggableComponents"
      :disabled="disableDrag"
      handle=".grippy"
    >
      <div
        v-for="(component, index) of mappedComponents"
        :key="component.UUID"
        class="luna-container component-content-band"
        :class="
          areTopLevelComponents
            ? 'luna-container-margin-20 luna-container-padding-bottom-20 component-card'
            : ''
        "
      >
        <div
          v-if="areTopLevelComponents"
          class="grid-x header-block luna-container-margin-bottom-20"
          :class="{ 'component-has-error': componentHasError([component]) }"
        >
          <div
            v-if="isUnrestrictedSite && !individualEditMode"
            class="cell luna_small-1"
          >
            <span class="grippy"></span>
          </div>
          <div class="cell auto">
            <div
              class="grid-x flex-flow--clear"
              :class="individualEditMode ? 'align-left' : 'align-center'"
            >
              <Icon
                v-if="
                  isUnrestrictedSite &&
                    !individualEditMode &&
                    !componentsBeingRenamed[component.UUID]
                "
                :iconSize="'10'"
                :iconColor="'neutral-90'"
                :customClass="'icon-position'"
                :title="'Rename section'"
                :iconName="'edit-file'"
                @click="editComponentName(component)"
              />
              <h3
                v-if="
                  individualEditMode || !componentsBeingRenamed[component.UUID]
                "
                :class="{
                  'component-has-error': componentHasError([component]),
                }"
              >
                {{
                  individualEditMode
                    ? 'Edit...'
                    : componentDisplayName(component)
                }}
              </h3>
              <input
                :id="`rename-${component.UUID}`"
                v-if="componentsBeingRenamed[component.UUID]"
                :value="componentDisplayName(component)"
                @change="updateComponentName($event, component.UUID)"
                @blur="closeComponentRename(component)"
                @keyup.enter="closeComponentRename(component)"
              />
            </div>
          </div>
          <div
            v-if="!individualEditMode && deleteEnabled && isUnrestrictedSite"
            class="cell shrink"
          >
            <Icon
              :iconSize="'10'"
              :iconColor="'neutral-90'"
              :title="'Delete'"
              :iconName="'trash'"
              @click="deleteComponent(component)"
              :customClass="{
                'margin-med': true,
                'component-has-error': componentHasError([component]),
                disabled: componentIsOriginalCH(component),
              }"
            />
          </div>
          <div class="cell shrink">
            <Icon
              :disabled="!showExpand(component)"
              :iconSize="'10'"
              :iconColor="'neutral-90'"
              :iconName="{ default: 'chevron-down', active: 'chevron-up' }"
              :customClass="'margin-right-lg'"
              :isActive="isOpen[component.UUID]"
              @click="
                expandComponent(component.UUID, componentDisplayName(component))
              "
            />
          </div>
        </div>

        <div class="grid-x grid-padding-x">
          <!--display tooltip if there is one (parent components only)-->
          <div
            v-if="areTopLevelComponents && isOpen[component.UUID]"
            :class="
              isMobileScreen
                ? ''
                : 'cell luna_small-4 luna-container-margin-top-10'
            "
            :style="isMobileScreen ? { display: 'none' } : {}"
          >
            <div v-if="component.Tooltip" class="luna-container-margin-left-10">
              <h5>About {{ component.Name }}</h5>
              <p v-html="component.Tooltip"></p>
            </div>

            <!-- extra tooltip info for components that need it -->
            <div
              v-for="(tooltip, index) of componentTooltip"
              :key="index"
              class="luna-container-margin-left-10"
            >
              <div v-if="index === component.UUID">
                <span v-html="tooltip"></span>
              </div>
            </div>
          </div>

          <!-- use group component instead of fields -->
          <div
            :class="
              !areTopLevelComponents
                ? 'cell luna_small-12 center dotted'
                : isMobileScreen
                ? 'cell luna_small-12 center'
                : 'cell luna_small-8 center'
            "
            :style="
              isMobileScreen ? { maxWidth: 600 + 'px' } : { width: 600 + 'px' }
            "
          >
            <div class="grid-x align-right">
              <!-- subcomponent header -->
              <template v-if="!areTopLevelComponents">
                <!--show subcomponent name-->
                <div class="cell auto">
                  <h4>{{ component.Name }}</h4>
                </div>

                <!--up button to reorder subcomponents-->
                <div
                  class="cell luna_small-1"
                  v-if="canReorderUp(index, component)"
                >
                  <span
                    class="unicode-button uni-up"
                    @click="reorderUp(component.UUID)"
                  ></span>
                </div>

                <!--down button to reorder subcomponents-->
                <div
                  v-if="
                    canReorderDown(index, component, mappedComponents.length)
                  "
                  class="cell luna_small-1"
                >
                  <span
                    class="unicode-button uni-down"
                    @click="reorderDown(component.UUID)"
                  ></span>
                </div>

                <!--delete button to remove subcomponents-->
                <div
                  v-if="canDeleteSubComponent(component.parentComponent)"
                  class="cell luna_small-1"
                >
                  <span
                    class="unicode-button uni-close"
                    @click="
                      deleteSubComponent(
                        component.UUID,
                        componentName(component),
                      )
                    "
                  ></span>
                </div>
              </template>
            </div>

            <div v-show="isOpen[component.UUID] || !areTopLevelComponents">
              <!--loop over fields and create vue components for them-->
              <div
                v-for="field of sortedFields(component)"
                :key="component.Fields[field].UUID"
              >
                <div v-if="displayFieldLookup[component.Fields[field].UUID]">
                  <component
                    :is="component.Fields[field].Type"
                    :name="component.Fields[field].Name"
                    :dataSource="component.Fields[field].Source"
                    :selectedValue="component.Fields[field].Value"
                    :uuid="component.Fields[field].UUID"
                    :componentUUID="component.UUID"
                    :isDirty="dirtyInventory[component.Fields[field].UUID]"
                    :minItems="component.MinItems"
                    :maxItems="component.MaxItems"
                    :metaData="component.Fields[field].MetaData"
                    :validation="component.Fields[field].Validation"
                    :data="component.Data"
                    :parentName="componentName(component)"
                    v-on:add-tooltip="addTooltip"
                    v-on:remove-tooltip="removeTooltip"
                    :class="{
                      'field-error': fieldHasError(
                        component.Fields[field].UUID,
                      ),
                    }"
                  >
                    <h5>
                      Cannot render field
                      {{ field.Name }}
                      of type
                      {{ field.Type }}
                      component doesn't exist in registry
                    </h5>
                  </component>
                </div>
              </div>

              <!--an Active Toggle will show/hide Subcomponents/View/PostView on same Component-->
              <div v-if="trueActiveToggle(component)">
                <!--render the component's view if it has one-->
                <div v-if="component.View">
                  <component
                    :is="component.View"
                    :data="component.Data"
                    :subComponentTemplate="component.SubComponentTemplate"
                    :name="componentName(component)"
                    :subComponents="component.SubComponents"
                    :minItems="component.MinItems"
                    :maxItems="component.MaxItems"
                    :parentUUID="component.UUID"
                    :isTopLevel="areTopLevelComponents"
                    v-on:add-tooltip="addTooltip"
                    v-on:remove-tooltip="removeTooltip"
                  ></component>
                </div>

                <div v-if="component.UseGroup">
                  <!--control subcomponents as a group -->
                  <component
                    :is="component.UseGroup"
                    :data="component.Data"
                    :subComponents="component.SubComponents"
                    :parentUUID="component.UUID"
                    :subComponentTemplate="component.SubComponentTemplate"
                  >
                    <h5>
                      Cannot render group: {{ component.UseGroup }} - component
                      doesn't exist in registry
                    </h5>
                  </component>
                </div>
                <div v-else>
                  <!--create another EditorSiteComponent to hold the subcomponents-->
                  <EditorSiteComponent
                    :components="component.SubComponents"
                    :canDeleteSubComponent="canDeleteSubComponent"
                    :areTopLevelComponents="false"
                    :defaultOpen="true"
                    :individualEditMode="false"
                  ></EditorSiteComponent>
                </div>

                <!--render the component's PostView if it has one-->
                <div v-if="component.PostView">
                  <component
                    :is="component.PostView"
                    :data="component.Data"
                    :subComponentTemplate="component.SubComponentTemplate"
                    :name="componentName(component)"
                    :subComponents="component.SubComponents"
                    :minItems="component.MinItems"
                    :maxItems="component.MaxItems"
                    :parentUUID="component.UUID"
                    :isTopLevel="areTopLevelComponents"
                  ></component>
                </div>
              </div>
              <div
                v-if="component.CallToAction && component.CallToAction.Editable"
              >
                <div
                  v-for="callToActionItem of component.CallToAction.Data"
                  :key="callToActionItem.Name"
                >
                  <CallToAction
                    :component="component"
                    :callToActionItem="callToActionItem"
                  ></CallToAction>
                </div>
              </div>
            </div>
            <div
              v-if="
                individualEditMode &&
                  isOpen[component.UUID] &&
                  areTopLevelComponents
              "
            >
              <div class="float-right">
                <button
                  :disabled="
                    !dirtyInventory[component.UUID] ||
                      preventSaveDueToValidation
                  "
                  class="luna-button luna-button-small luna-button-primary standard-width top-margin"
                  @click="componentSave(component.UUID)"
                >
                  Save
                </button>
                <button
                  :disabled="!Boolean(dirtyInventory[component.UUID])"
                  class="luna-button luna-button-small luna-button-secondary standard-width top-margin"
                  @click="componentRevert(component.UUID)"
                >
                  Revert
                </button>
              </div>
            </div>
          </div>
          <div>
            <!-- comment box popout, parent components only.  don't show in compliance edit mode -->
            <div
              v-if="
                areTopLevelComponents &&
                  !individualEditMode &&
                  isOpen[component.UUID]
              "
            >
              <Comments :comments="comments[component.ID]" />
            </div>
          </div>
        </div>
      </div>
    </draggable>
  </div>
</template>

<script>
import FieldRegistry from '@/components/FieldRegistry';
import GroupRegistry from '@/components/GroupRegistry';
import ViewRegistry from '@/components/ViewRegistry';
import Comments from './Comments';
import { adobeAnalytics } from '@/service/adobeAnalytics';
import { util } from '@/util';
import draggable from 'vuedraggable';
import ValidationErrorMessage from '../../components/common/validationErrorMessage';
import ValidationError from '../../components/common/validationError';
import CallToAction from './../../components/common/callToAction.vue';
import Toast from '@/components/common/toast';
import Icon from '../../components/common/Icon.vue';

// Don't show descriptions text below this resolution
const MOBILE_TOOLTIP_BREAKPOINT = 865;

export default {
  components: {
    ...FieldRegistry,
    ...GroupRegistry,
    ...ViewRegistry,
    Comments,
    draggable,
    ValidationErrorMessage,
    ValidationError,
    CallToAction,
    Toast,
    Icon,
  },
  name: 'EditorSiteComponent',
  props: {
    components: Array,
    canDeleteSubComponent: Function,
    comments: Object,
    areTopLevelComponents: Boolean,
    individualEditMode: Boolean,
    defaultOpen: Boolean,
  },
  data() {
    return {
      isOpen: {},
      screen_width: 0,
      componentTooltip: {},
      displayFieldLookup: {},
      validationUnsubscribe: null,
      originalContentHubID: '',
      componentsBeingRenamed: {},
    };
  },
  async created() {
    window.addEventListener('resize', this.handleResize);
    this.handleResize();

    // default open mode
    // loop through all components looking for uuids and default to `true` for open (Causes we care about office cases)
    if (this.defaultOpen) {
      (this.components || []).forEach(c => {
        this.$set(this.isOpen, c.UUID, true);
      });
    }

    await this.populateDisplayField();
    this.originalContentHubID = '5ea2a325-5e30-4c2c-854c-f4a658ef3685';
    // re-paint the DOM when a component's or field's validation status changes so we can update the error CSS immediately
    this.validationUnsubscribe = this.$store.subscribe(mutation => {
      if (mutation.type !== 'setValidation') {
        return;
      }
      this.$forceUpdate();
    });
  },
  destroyed() {
    window.removeEventListener('resize', this.handleResize);
    this.validationUnsubscribe();
  },
  watch: {
    mappedComponents: 'populateDisplayField',
  },
  computed: {
    mappedComponents() {
      if (!this.components || !this.components.length) {
        return [];
      }

      const currentPage = this.$store.getters[
        'templateModule/selectedPageDataSections'
      ];

      if (
        currentPage &&
        this.areTopLevelComponents &&
        !this.individualEditMode
      ) {
        const sortedComponents = [];
        for (let section of currentPage) {
          const component = this.components.find(c => c.ID === section.Guid);
          if (!component) {
            continue;
          }
          // copy over generated UUID from template to use for deleting
          component.DeleteId = section.UUID;
          sortedComponents.push(component);
        }
        return sortedComponents;
      }

      return util.deepClone(this.components).map(component => {
        // Special logic for Causes We Care About on Office sites
        if (
          component.Type === 'component-additional-cause-list' &&
          !this.typeHasSubcomponents('component-cause-photo-with-text')
        ) {
          // replace component with notification
          component.Fields = [
            {
              Name: 'Text Label',
              Type: 'text-label',
              PartialID: 'TextLabel',
              Value: 'Requires at least one main cause defined above.',
              ID: 'testimonial-text-label',
            },
          ];
          component.SubComponents = [];
        } else if (
          component.Type === 'component-additional-cause-list' ||
          component.Type === 'component-cause-photo-with-text'
        ) {
          // prevent reordering
          component.preventReordering = true;
        }

        return component;
      });
    },
    preventSaveDueToValidation() {
      return this.$store.state.preventSaveDueToValidation;
    },
    dirtyInventory() {
      return this.$store.state.dirtyInventory;
    },
    isMobileScreen() {
      return this.screen_width <= MOBILE_TOOLTIP_BREAKPOINT;
    },
    draggableComponents: {
      get() {
        return this.$store.getters['templateModule/selectedPageDataSections'];
      },
      set(value) {
        this.$store.commit('templateModule/updateDraggableComponents', value);
      },
    },
    disableDrag() {
      return !this.areTopLevelComponents || !this.deleteEnabled;
    },
    deleteEnabled() {
      if (
        this.$store.state.currentNav !== 'Header' &&
        this.$store.state.currentNav !== 'Footer'
      ) {
        return true;
      }

      return !this.$store.getters['templateModule/isEntitySite'];
    },
    isUnrestrictedSite() {
      return this.$store.getters['templateModule/isUnrestrictedSite'];
    },
  },
  methods: {
    async populateDisplayField() {
      for (let component of this.mappedComponents) {
        if (!component.Fields) {
          continue;
        }

        for (let field of Object.values(component.Fields)) {
          if (field.Hidden) {
            this.$set(this.displayFieldLookup, field.UUID, false);
            continue;
          }

          const visible = await util.evaluateRule(
            field.Visibility,
            this.$store,
            component.Fields,
            true,
          );

          this.$set(this.displayFieldLookup, field.UUID, visible);
        }
      }
    },
    typeHasSubcomponents(type) {
      let foundMatch = false;

      function pushComponents(components) {
        if (!components) return;
        for (let c of components) {
          if (c.Type === type && c.SubComponents && c.SubComponents.length) {
            foundMatch = true;
          }
          pushComponents(c.SubComponents);
        }
      }

      pushComponents(this.$store.state.siteData.Components);

      return foundMatch;
    },
    async componentSave(uuid) {
      // save of a single component = published state + draft state of only the one component
      await this.$store.dispatch('saveSingleComponent', { uuid });

      // reload draft preview image
      this.$store.dispatch('refreshImage', { uuid });
    },
    componentRevert(uuid) {
      // revert is reverting in process changes of just the one component back to pristine state
      this.$store.dispatch('revertSingleComponent', { uuid });
    },
    trueActiveToggle(component) {
      if (component && component.Fields) {
        for (let [key, value] of Object.entries(component.Fields)) {
          if (key.indexOf('active') > 0) {
            // return value of 'active' field
            return value.Value === 'true';
          }
        }
      }

      // always show if we don't have an 'active' field
      return true;
    },
    sortedFields(component) {
      let keys = Object.keys(component.Fields || {}).filter(d => {
        return d.slice(-7) !== 'sort-id';
      });

      keys.sort((a, b) => {
        return component.Fields[a].Order - component.Fields[b].Order;
      });

      return keys.filter(key => component.Fields[key].Type !== 'group-data');
    },
    expandComponent(uuid, name) {
      if (this.isOpen[uuid] === undefined) {
        this.$set(this.isOpen, uuid, true);
      } else {
        this.isOpen[uuid] = !this.isOpen[uuid];
      }
      if (this.$store.state.baseWebsiteData) {
        adobeAnalytics.containerToggleClick(
          this.$store.state.baseWebsiteData.Data[0].Type,
          this.$store.state.baseWebsiteData.Data[0].Name,
          this.$store.state.currentNav,
          name,
          this.isOpen[uuid],
        );
      }
    },
    showExpand(component) {
      if (component.SubComponents && component.SubComponents.length > 0) {
        return true;
      }

      if (component.View || component.PostView) {
        return true;
      }

      if (!component.Fields) {
        return false;
      }

      for (let field of Object.values(component.Fields)) {
        if (!field.Hidden) {
          return true;
        }
      }
      return false;
    },
    handleResize() {
      this.screen_width = window.innerWidth;
    },
    addTooltip(uuid, data) {
      this.$set(this.componentTooltip, uuid, data);
    },
    removeTooltip(uuid) {
      this.$set(this.componentTooltip, uuid, null);
    },
    canReorderUp(index, component) {
      if (
        component.SubComponents ||
        this.areTopLevelComponents ||
        component.preventReordering
      ) {
        return false;
      }

      return index !== 0;
    },
    canReorderDown(index, component, arrayLength) {
      if (
        component.SubComponents ||
        this.areTopLevelComponents ||
        component.preventReordering
      ) {
        return false;
      }

      return index !== arrayLength - 1;
    },
    reorderUp(uuid) {
      this.$store.dispatch('reorderSubComponent', { direction: 'up', uuid });
    },
    reorderDown(uuid) {
      this.$store.dispatch('reorderSubComponent', { direction: 'down', uuid });
    },
    deleteSubComponent(uuid, name) {
      if (this.$store.state.baseWebsiteData) {
        adobeAnalytics.websiteCloseClick(
          this.$store.state.baseWebsiteData.Data[0].Type,
          this.$store.state.baseWebsiteData.Data[0].Name,
          this.$store.state.currentNav,
          name,
        );
      }
      this.$store.dispatch('deleteComponent', { uuid });
    },
    componentDisplayName(component) {
      if (component.CustomName) {
        return component.CustomName;
      }

      const title = this.getTitleField(component);
      if (title && title.Value) {
        return title.Value;
      }

      return this.componentName(component);
    },
    componentName(component) {
      return (
        component.Name ||
        component.Partial.replace('.partial', '')
          .replace('.hero', '-hero')
          .replaceAll('.', ' ')
          .toLowerCase()
          .split('-')
          .map(d => d.slice(0, 1).toUpperCase() + d.slice(1))
          .join(' ')
      );
    },
    getTitleField(component) {
      if (component.Fields == null) {
        return null;
      }
      for (const field of Object.values(component.Fields)) {
        if (field.Name === 'Title') {
          return field;
        }
      }
      return null;
    },
    deleteComponent(component) {
      if (component.ID === this.originalContentHubID) {
        this.$refs.toast.show(
          'failure',
          `Error deleting: default content hub cannot be deleted`,
        );
      } else {
        this.$store.dispatch('deleteComponent', { uuid: component.UUID });
        this.$store.commit(
          'templateModule/deleteComponent',
          component.DeleteId,
        );
      }
    },
    fieldHasError(uuid) {
      return this.$store.state.validationStatus[uuid] === false;
    },
    componentHasError(components) {
      if (!components) {
        return false;
      }
      for (let component of components) {
        for (let field of Object.values(component.Fields)) {
          if (this.fieldHasError(field.UUID)) {
            return true;
          }
        }
        if (this.componentHasError(component.SubComponents)) {
          return true;
        }
      }
      return false;
    },
    componentIsOriginalCH(component) {
      if (!component) {
        return false;
      }
      return component.ID === this.originalContentHubID;
    },
    putCursorInInput(id) {
      const input = document.getElementById(id);
      input.select();
      const inputTextLength = input.value.length;
      input.setSelectionRange(inputTextLength, inputTextLength);
    },
    editComponentName(component) {
      this.$set(
        this.componentsBeingRenamed,
        component.UUID,
        this.componentDisplayName(component),
      );
      this.$nextTick(() => {
        // wait for DOM to update and then put cursor in <input>
        this.putCursorInInput(`rename-${component.UUID}`);
      });
    },
    updateComponentName(evt, uuid) {
      this.$set(this.componentsBeingRenamed, uuid, evt.target.value);
    },
    closeComponentRename(component) {
      const titleField = this.getTitleField(component);
      let maxCharCount = 0;
      if (titleField) {
        for (let rule of titleField.Validation) {
          if (rule.Check === 'MaxCharCount') {
            maxCharCount = parseInt(rule.Value, 10);
            break;
          }
        }
      }

      if (
        maxCharCount > 0 &&
        this.componentsBeingRenamed[component.UUID].length > maxCharCount
      ) {
        this.$refs.toast.show(
          'failure',
          `Name has exceeded the maximum amount of ${maxCharCount} characters.`,
        );

        // revert the component name change
        this.$set(
          this.componentsBeingRenamed,
          component.UUID,
          this.componentDisplayName(component),
        );

        this.putCursorInInput(`rename-${component.UUID}`);
        return;
      }

      if (
        this.componentDisplayName(component) !==
        this.componentsBeingRenamed[component.UUID]
      ) {
        this.$store.dispatch('onChangeComponentName', {
          UUID: component.UUID,
          value: this.componentsBeingRenamed[component.UUID],
        });
      }

      this.$set(this.componentsBeingRenamed, component.UUID, null);
    },
  },
};
</script>
<style scoped lang="scss">
h5 {
  font-weight: bold !important;
}

.component-card {
  border: 1px solid $neutral-40;
  border-radius: 10px;
  background-color: rgb(252, 252, 255);
}

.header-block {
  border-radius: 10px 10px 0 0;
  padding: 10px 0 5px 20px;
  border-bottom: 1px solid $neutral-40;
  background-color: $neutral-10;
}

.center {
  margin-left: auto;
  margin-right: auto;
}

.dotted {
  border: 1px dashed $neutral-60;
  padding: 20px;
  margin: 10px 0 10px 0;
  border-radius: 20px;
  max-width: 95%;
}

.luna-icon_action.luna-icon_action-size-20 .luna-icon_action--icon {
  padding: 0.3rem;
}

.grippy {
  width: 20px;
  height: 20px;
  display: inline-block;
  line-height: 5px;
  cursor: grab;
  letter-spacing: 2px;
  color: $neutral-60;
  text-shadow: 1px 0 1px $neutral-100;
}
.grippy::after {
  content: '.. .. .. ..';
}
.flex-flow--clear {
  flex-flow: inherit;
}
.icon-position {
  cursor: pointer;
  margin: 0.25rem 0.5rem 0 0;
}
h3 {
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  max-width: 60vw;
}
input {
  font-size: 1.5rem;
  margin-bottom: 2px;
  width: 95%;
}
</style>
